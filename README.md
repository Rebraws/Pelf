# Pelf


Pelf is a C++20 library for extracting information from PE and ELF file formats at compile time and runtime, currently it only supports parsing of 64-bit little endian files.

## Getting Started
### Prerequisites

To compile the code, it requires at least a C++20 compiler with the following C++20 supported features

- constexpr std::copy()
- concepts
- consteval specifier
- std::is_constant_evaluated()

### Dependencies
- [Boost.Hana](http://boostorg.github.io/hana/) 

## Running the tests
You can compile and run the tests by running
```
make test && ./tests
```

## How to use the library
Using pelf for parsing Pe/ELF files at runtime it's pretty simple, once you've read your file into some container like a vector, you can pass it to the Pe/Elf constructor, if the file is an invalid PE/ELF file then an exception will be thrown

##### Parsing a Pe file at runtime 
```
#include "pelfParser.h"
...
/* Reading contents of the file into a vector ...*/
...
try {
    pelf::Pe pe{ data };
} catch(pelf::pelfException& e) {
    /* Handle exception */
}
```

##### Parsing an ELF file at runtime 
```
#include "pelfParser.h"
...
/* Reading contents of the file into a vector ...*/
...
try {
    pelf::Elf elf{ data };
} catch(pelf::pelfException& e) {
    /* Handle exception */
}
```

Once parsing is done you can extract all the information of the PE/ELF file, let's see an example where we print the entry point of an ELF file

##### Printing the entry point of an ELF file at runtime 
```
#include "pelfParser.h"
...
/* Reading contents of the file into a vector ...*/
...
try {
    pelf::Elf elf{ data };
    /* The entry point is in the Elf header, so first we need to get that header */
    const auto elf_header = elf.getHeaders().elfHeader;
    
    /* Then we print the entry point as an hexadecimal value*/
    std::cout << std::hex << "Entry Point: " << elf_header.e_entry << '\n';
} catch(pelf::pelfException& e) {
    /* Handle exception */
}
```

As you might see, parsing and extracting information at runtime is really simple, but doing it at compile time it's a bit more tricky, let's see how to do it.

First, in order to parse a file at compile time you need have access to the file data at compile time, you can achieve this in different ways, I'd recommend using xxd with the -i flag which allows you to output the binary in a C include file style, and then using a constexpr std::array to hold that data.

Once you have the binary data from your file available at compile time, parsing can be done like this:
#### Parsing an ELF file at compile time
```
#include "pelfParser.h"
#include "headerFileWithBinaryData.h" // header file generated by xxd

int main() {
    
    /* Get the number of entries in the section table and program header table*/
    static constexpr auto tables_size = pelf::Elf<decltype(data)>::getElfTablesSize(data);
    
    static constexpr pelf::Elf<decltype(data), tables_size.sectionTable, tables_size.programTable> elf{ data };
    
    /* Printing the entry point */
    static constexpr auto elf_header = elf.getHeaders().elfHeader;
    std::cout << std::hex << "Entry Point: " << elfHeader.e_entry << '\n';
    
    return EXIT_SUCCESS;    
}

```

Notice that there's no try-catch block, in this case is not needed, if the input passed to the constructor is an invalid Elf file then the program won't compile

Finally, let's see an example parsing a Pe file at compile time and printing the ImageBase of the file
#### Parsing a Pe at compile time
```
#include "pelfParser.h"
#include "headerFileWithBinaryData.h" // header file generated by xxd

int main() {

    /* First we need the number of entries in the section table */
    static constexpr auto num_entries_section_table = pelf::getPeNumberOfSections(data);
    
    /* Now we instantiate the Pe class */
    static constexpr pelf::Pe<decltype(data), num_entries_section_table> pe{ data };
        
    /* The ImageBase is in the Optional Header, more precisely in the windows specific fields section */
    static constexpr auto wsf = pe.getHeaders().getWindowsSpecificFields();
    
    std::cout << std::hex << "ImageBase: " << wsf.ImageBase << '\n'; 
        
    return EXIT_SUCCESS;
}
```




# Development
Want to contribute? Feel free to submit a pull request either to fix a bug or adding more tests cases or expanding the library with new features (like supporting 32-bit and big-endian files) 

# Contact Me
[Twitter](https://twitter.com/Rebraws1)
[Mail](Rebraws@protonmail.com)


## License

MIT
